# byproducts.jl

"""
    StartWorkers(nwrkrs::Int)

Start workers if needed.
"""
function StartWorkers(nwrkrs::Int)
   set_workers = nwrkrs
   nworkers() < set_workers ? addprocs(set_workers) : nothing
   nworkers()
end

"""
    TaskDriver()

Broacast / distribute tasks over indices (e.g. file indices)

For example:

```
using CbiomesProcessing, Distributed, SparseArrays
StartWorkers(3)
@everywhere using CbiomesProcessing, SparseArrays
TaskDriver(1:12)
```

And to visualize results, for example:

```
using FortranFiles, Plots
k=1
recl=720*360*4
fil="diags_interp/ETAN/ETAN.0000000732.data"
#fil="diags_interp/THETA/TETA.0000000024.data"
f =  FortranFile(fil,"r",access="direct",recl=recl,convert="big-endian")
tmp=read(f,rec=k,(Float32,(720,360))); close(f)
heatmap(tmp)
```
"""
function TaskDriver(indx::Union{UnitRange{Int},Array{Int,1},Int})
    i=collect(indx)
    length(i)>1 ? i=distribute(i) : nothing
    isa(i,DArray) ? println(i.indices) : nothing
    #MetaFile=cbioproc_task1.(i)
    #loop_task2.(i)
    loop_task4.(i)
end

"""
    MetaFileRead(filIn::String)

Reads a meta file generated by MITgcm
"""
function MetaFileRead(FileName::String)

    MetaFile=FileName[1:end-5]*".meta"
    f = open(MetaFile)
    lines = readlines(f)
    close(f)

    MetaFile=Dict("MetaFile" => MetaFile)
    while !isempty(lines)
        line=popfirst!(lines)
        i0=findfirst(isequal('='), line)
        i1=findfirst(isequal(';'), line)
        !isnothing(i0) ? nam=strip(line[1:i0-1]) : nam=""
        val=nothing
        #show(line)
        if nam=="dimList"
            #special case: dimList
            val=fill(0.,(MetaFile["nDims"],3))
            for ii=1:MetaFile["nDims"]
                line=popfirst!(lines)
                tmp1=split(line,",")
                #tmp1=map(x->(v = tryparse(Int,x); ismissing(v) ? 0.0 : v),tmp1)
                val[ii,:]=parse.(Int,tmp1[1:3])
            end
            line=popfirst!(lines)
        elseif nam=="fldList"
            #special case: fldList
            line=popfirst!(lines)
            tmp1=split(line,"'")
            val=String.(tmp1[2:2:end])
            line=popfirst!(lines)
        elseif nam=="dataprec"
            #sepcial case: dataprec
            tmp1=split(line)
            tmp1[4]=="'float32'" ? val=Float32 : val=Float64
        elseif nam=="nDims"
            #sepcial case: nDims
            tmp1=split(line[i0+1:i1-1])
            val=parse(Int64,tmp1[2])
        end
        #
        if ~isnothing(val)
            tmp2=Dict(nam => val)
            MetaFile=merge(MetaFile,tmp2)
        end
    end

    return MetaFile
end

"""
    MatrixInterp(in::Array{T,N},SPM,siz) where {T,N}

Interpolate `in` using `SPM` to grid of size `siz`.
"""
function MatrixInterp(in::Array{T,N},SPM::SparseMatrixCSC,siz) where {T,N}
    #input
    l=size(in,1)*size(in,2);
    m=size(in,3);
    tmp1=reshape(in,l,m)
    tmp0=Float64.(.!(isnan.(tmp1)))
    tmp1[isnan.(tmp1)].=0.
    siz=siz[1],siz[2],m
    #matrix product
    tmp0=SPM*tmp0
    tmp1=SPM*tmp1
    tmp1=tmp1./tmp0
    #this may be redundant:
    tmp1[tmp0 .== 0.] .= NaN
    #output
    out=reshape(tmp1,siz)
    m==1 ? out=dropdims(out,dims=3) : nothing
    return out
end

"""
    prep_MTRX()

Repackage interpolation matrix, mask, etc to `.jld` file.
"""
function prep_MTRX()
    GCMGridSpec()
    GCMGridLoad()
    msk2d=mask(view(MeshArrays.hFacC,:,:,1),NaN,0)
    msk3d=mask(MeshArrays.hFacC,NaN,0)
    msk2d=convert2gcmfaces(msk2d)
    msk3d=convert2gcmfaces(msk3d)

    dirIn=""
    MTRX,lon,lat=read_SPM(dirIn)
    lon=vec(lon[:,1])
    lat=vec(lat[1,:])

    fid = open("GRID_LLC90/RC.data")
    dep=Array{Float64,1}(undef,50)
    read!(fid,dep)
    close(fid)
    dep = -hton.(dep)

    siz2d=(length(lon),length(lat))
    siz3d=(length(lon),length(lat),50)

    save(dirIn*"MTRX.jld", "MTRX", MTRX, "lon", lon, "lat", lat, "dep", dep,
    "msk2d", msk2d, "msk3d", msk3d, "siz2d", siz2d, "siz3d", siz3d)
end

"""
    read_SPM(dirIn::String)

Reads pre-computed interpolation (sparse matrix) from
`dirIn*"interp_precomputed.mat"`.
"""
function read_SPM(dirIn::String)
    #vars = matread(dirIn*"interp_precomputed.mat")
    file = matopen(dirIn*"interp_precomputed.mat")
    interp=read(file, "interp")
    lon=read(file, "lon")
    lat=read(file, "lat")
    SPM=interp["SPM"]
    #println(keys(interp))
    close(file)
    return SPM,lon,lat
end
